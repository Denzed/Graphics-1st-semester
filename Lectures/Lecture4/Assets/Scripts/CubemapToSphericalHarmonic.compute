#include "UnityCG.cginc"

// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel ComputeHarmonics

#define pow2(x)       (x * x)          
#define PI            3.14159265359f
#define TWO_PI        6.28318530718f
#define FOUR_PI       12.56637061436f
#define INV_PI        0.31830988618f
#define INV_TWO_PI    0.15915494309f
#define INV_FOUR_PI   0.07957747155f
#define HALF_PI       1.57079632679f
#define INV_HALF_PI   0.636619772367f
#define SQRT_PI       1.77245385091f
#define INV_SQRT_PI   0.56418958354f
#define SQRT_3        1.73205080757f
#define SQRT_5        2.2360679775f

RWStructuredBuffer<float4> SH_0_1_r;
RWStructuredBuffer<float4> SH_0_1_g;
RWStructuredBuffer<float4> SH_0_1_b;

RWStructuredBuffer<float4> SH_2_r;
RWStructuredBuffer<float4> SH_2_g;
RWStructuredBuffer<float4> SH_2_b;

RWStructuredBuffer<float4> SH_2_rgb;

TextureCube<half4> _Env;
SamplerState samplerLinearRepeat;

uint Hash(uint s)
{
    s ^= 2747636419u;
    s *= 2654435769u;
    s ^= s >> 16;
    s *= 2654435769u;
    s ^= s >> 16;
    s *= 2654435769u;
    return s;
}

float Random(uint seed)
{
    return float(Hash(seed)) / 4294967295.0; // 2^32-1
}

float3 SampleColor(float3 direction)
{   
    return _Env.SampleLevel(samplerLinearRepeat, direction, 0);
}

[numthreads(1024, 1, 1)]
void ComputeHarmonics(uint id : SV_DispatchThreadID)
{
    const int THREADS = 1024;
    const int SAMPLES = 10;
    
    // See SH.shader for more details
    float4 results[7] = {
        float4(0, 0, 0, 0), // SH_0_1_r
        float4(0, 0, 0, 0), // SH_0_1_g
        float4(0, 0, 0, 0), // SH_0_1_b
        
        float4(0, 0, 0, 0), // SH_2_r
        float4(0, 0, 0, 0), // SH_2_g
        float4(0, 0, 0, 0), // SH_2_b
        
        float4(0, 0, 0, 0), // SH_2_rgb
    };
    
    const float4 SH_0_1 = float4(SQRT_3 * float3(-1, 1, -1), 1) * 0.5 * INV_SQRT_PI;
    const float4 SH_2 = float4(1, -1, -1, 0.5 / SQRT_3) * 0.5 * SQRT_5 * SQRT_3 * INV_SQRT_PI;
    const float SH_2_2 = 0.25 * SQRT_3 * SQRT_5 * INV_SQRT_PI;
    for (int s = 0; s < SAMPLES; s++) {
        const int s_id = id * SAMPLES + s;

        const float cosTheta = 2 * Random(2 * s_id    ) - 1;
        const float phi   = TWO_PI *  Random(2 * s_id + 1);

        const float sinTheta = sqrt(1 - pow2(cosTheta));

        const float4 dir = float4(
            sinTheta * sin(phi),
            sinTheta * cos(phi),
            cosTheta, 
            1.0
        );
        const float3 col = SampleColor(dir);

        for (int c = 0; c < 3; c++) {
            results[c    ] += col[c] * dir * pow2(SH_0_1);
            results[c + 3] += col[c] * (dir.xyzz * dir.yzxz * float4(1, 1, 1, 3) - float4(0, 0, 0, 1)) * pow2(SH_2);
        }
        results[6].rgb += col * (pow2(dir.x) - pow2(dir.y)) * pow2(SH_2_2);
    }
    const float weight = PI / SAMPLES;
    for (int c = 0; c < 3; c++) {
        results[c    ] *= weight;
        results[c + 3] *= weight;
    }
    results[6] *= weight;
    
    for (c = 0; c < 3; c++) {
        // Precomputing coefficients of max(0, cos(theta) for L=0
        results[c].w *= PI; 
        // Precomputing coefficients of max(0, cos(theta) for L=1
        results[c].xyz *= PI * 2 / 3;
    }
    
    for (c = 0; c < 4; c++) {
        // Precomputing coefficients of max(0, cos(theta) for L=2
        results[3 + c] *= PI / 4;
    } 
    
    SH_0_1_r[id] = results[0];
    SH_0_1_g[id] = results[1];
    SH_0_1_b[id] = results[2];
    
    SH_2_r[id] = results[3];
    SH_2_g[id] = results[4];
    SH_2_b[id] = results[5];    
}
