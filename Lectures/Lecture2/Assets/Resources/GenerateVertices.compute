// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel generateTexture TEXTURE_GENERATION
#pragma kernel marchCubes

const static uint3 LAYER_GROUP_SIZE = uint3(4, 4, 32);

const uniform float TIME;
const uniform int LAYER_OFFSET;
const uniform uint3 SPLIT_FACTOR;
const static float3 INV_SPLIT_FACTOR = 1.0 / SPLIT_FACTOR;

const uniform uint OCTAVE_COUNT;


#ifdef TEXTURE_GENERATION


#define SIMPLEX_4D
#include "Noise.cginc"                 // All noise belongs here
#undef SIMPLEX_4D

RWTexture2D<float> outSurfaceTexture;

float fWithOctaves(float3 p) {
    float result = 0.0;
    const static float PI = 3.14159265359;

    float q = 0.5;
    for (uint o = 0; o < OCTAVE_COUNT; ++o) {
        float4 pnt = float4(
            cos(p.x * 2 * PI),
            cos(p.y * 2 * PI),
            sin(p.x * 2 * PI),
            sin(p.y * 2 * PI)
        ) * q;

        q *= 2.0;
        result += snoise(pnt) / q;
    }
    return result;
}

[numthreads(16, 16, 1)]
void generateTexture (
    uint3 threadID : SV_DispatchThreadID
) {
    outSurfaceTexture[threadID.xy] = fWithOctaves(threadID * INV_SPLIT_FACTOR);
}

#else

// Cube
StructuredBuffer<int3> cubeVertices;

// Surface
Texture2D<float> surfaceTexture;
SamplerState samplerLinearRepeat;

float f(float3 p) {   // implicit surface definition
    p *= INV_SPLIT_FACTOR;
    
    return all(abs(p - 0.5) < 0.5) 
        ? surfaceTexture.SampleLevel(
             samplerLinearRepeat, 
             p.xy + float2(sin(TIME), cos(TIME)), 0
        ) + 0.2 - p.z * 3.0 
        : 0.0;
}

// Marching
StructuredBuffer<uint> caseToTrianglesCount;
StructuredBuffer<int3> caseToEdges;

struct VertexData {
    float3 pos, normal;
};

// Output points
RWStructuredBuffer<int> outPointsCount;
RWStructuredBuffer<VertexData> outPoints;

float3 getNormal(int3 a) {
    return normalize(float3(
        f(a + int3(1, 0, 0)) - f(a - int3(1, 0, 0)),
        f(a + int3(0, 1, 0)) - f(a - int3(0, 1, 0)),
        f(a + int3(0, 0, 1)) - f(a - int3(0, 0, 1))
    ));
}

const static uint2 vertexFromEdge[12] = {
    int2(0, 1), int2(1, 2), int2(2, 3), int2(3, 0), 
    int2(4, 5), int2(5, 6), int2(6, 7), int2(7, 4), 
    int2(0, 4), int2(1, 5), int2(2, 6), int2(3, 7), 
};

[numthreads(LAYER_GROUP_SIZE.x, LAYER_GROUP_SIZE.y, LAYER_GROUP_SIZE.z)]
void marchCubes (uint3 threadID : SV_DispatchThreadID) {
    int3 id = threadID + int3(0, 0, LAYER_OFFSET);

    uint cubeCase = 0;
    for (uint v = 0; v < 8; v++) {
        if (f(id + cubeVertices[v]) > 0) {
            cubeCase |= 1 << v;
        }
    }

    uint caseTriangles = caseToTrianglesCount[cubeCase];
    int index;
    InterlockedAdd(outPointsCount[0], 3 * caseTriangles, index);
    for (uint t = 0; t < caseTriangles; t++) {
        int3 triangleEdges = caseToEdges[cubeCase * 5 + t];

        for (uint e = 0; e < 3; e++) {
            uint2 ij = vertexFromEdge[triangleEdges[e]];

            int3 a = id + cubeVertices[ij.x];
            int3 b = id + cubeVertices[ij.y];
            
            float alpha = abs(f(a)) / (abs(f(a)) + abs(f(b)));
            
            VertexData res;

            res.pos = (id + lerp(cubeVertices[ij.x], cubeVertices[ij.y], alpha)) 
                    * INV_SPLIT_FACTOR;
            res.normal = normalize(lerp(getNormal(a), getNormal(b), alpha));
            
            outPoints[index + 3 * t + e] = res;
        }
    }
}


#endif