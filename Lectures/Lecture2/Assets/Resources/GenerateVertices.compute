// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel marchCubes

#include "UnityShaderVariables.cginc"  // for time
#include "Noise.cginc"                 // Hiding creepy copy-paste

const static uint3 LAYER_GROUP_SIZE = uint3(16, 16, 1);

const uniform uint BASE_LAYER;
const uniform uint LAST_LAYER;
const uniform uint3 SPLIT_FACTOR;
const static float3 INV_SPLIT_FACTOR = 1.0 / SPLIT_FACTOR;

// Cube
StructuredBuffer<int3> cubeVertices;

// Marching
StructuredBuffer<uint> caseToTrianglesCount;
StructuredBuffer<int3> caseToEdges;

struct Triangle {
    float3 vn[3][2];
};

groupshared float cache[LAYER_GROUP_SIZE.x][LAYER_GROUP_SIZE.y][5];

// Output triangles
RWStructuredBuffer<int> outTrianglesCount;
RWStructuredBuffer<Triangle> outTriangles;

float f(float3 p) {   // implicit surface definition
    return all(abs(p - 0.5) < 0.5) ? snoise(p + _SinTime.xyz) : 0.0;
}

#define cachedF_(x, y, z) cache[x][y][(z % 5 + 5) % 5]

float cachedF(int3 a) {
    return cachedF_(a.x, a.y, a.z);
}

float3 getNormal(int3 a) {
    return normalize(float3(
        cachedF(a + int3(1, 0, 0)) - cachedF(a - int3(1, 0, 0)),
        cachedF(a + int3(0, 1, 0)) - cachedF(a - int3(0, 1, 0)),
        cachedF(a + int3(0, 0, 1)) - cachedF(a - int3(0, 0, 1))
    ));
}

const static uint2 vertexFromEdge[12] = {
    int2(0, 1), int2(1, 2), int2(2, 3), int2(3, 0), 
    int2(4, 5), int2(5, 6), int2(6, 7), int2(7, 4), 
    int2(0, 4), int2(1, 5), int2(2, 6), int2(3, 7), 
};

[numthreads(LAYER_GROUP_SIZE.x, LAYER_GROUP_SIZE.y, LAYER_GROUP_SIZE.z)]
void marchCubes (
    uint3 groupID : SV_GroupID, 
    uint3 groupThreadID : SV_GroupThreadID
) {
    int3 cacheId0 = int3(groupThreadID.xy, BASE_LAYER);
    int3 id = groupID * (LAYER_GROUP_SIZE - int3(3, 3, 0)) 
            + cacheId0 - int3(1, 1, 0);

    bool isMarching = all(
        0 < cacheId0.xy 
        && cacheId0.xy < (int2) LAYER_GROUP_SIZE.xy - 2 
        && id < (int3) SPLIT_FACTOR
    );

    cachedF_(cacheId0.x, cacheId0.y, cacheId0.z + 4) = 
        0.0;
    cachedF_(cacheId0.x, cacheId0.y, cacheId0.z + 0) = 
        f(id * INV_SPLIT_FACTOR);
    cachedF_(cacheId0.x, cacheId0.y, cacheId0.z + 1) = 
        f((id + int3(0, 0, 1)) * INV_SPLIT_FACTOR);
    cachedF_(cacheId0.x, cacheId0.y, cacheId0.z + 2) = 
        f((id + int3(0, 0, 2)) * INV_SPLIT_FACTOR);
    
    for (uint layer = BASE_LAYER; layer < LAST_LAYER; ++layer) {
        GroupMemoryBarrierWithGroupSync();

        cachedF_(cacheId0.x, cacheId0.y, layer + 3) = 
            f((id + int3(0, 0, layer - BASE_LAYER + 3)) * INV_SPLIT_FACTOR);

        int3 cacheId = int3(cacheId0.xy, layer);

        if (isMarching) {
            uint cubeCase = 0;
            for (uint v = 0; v < 8; v++) {
                if (cachedF(cacheId + cubeVertices[v]) > 0) {
                    cubeCase |= 1 << v;
                }
            }

            uint caseTriangles = caseToTrianglesCount[cubeCase];
            int index;
            InterlockedAdd(outTrianglesCount[0], caseTriangles, index);
            for (uint t = 0; t < caseTriangles; t++) {
                int3 triangleEdges = caseToEdges[cubeCase * 5 + t];

                Triangle res;

                for (uint e = 0; e < 3; e++) {
                    uint2 ij = vertexFromEdge[triangleEdges[e]];

                    int3 a = cacheId + cubeVertices[ij.x];
                    int3 b = cacheId + cubeVertices[ij.y];
                    
                    float alpha = abs(cachedF(a)) / (abs(cachedF(a)) + abs(cachedF(b)));
                                                                    
                    res.vn[e][0] = (
                        float3(id.xy, layer) 
                        + cubeVertices[ij.x] * (1 - alpha) + cubeVertices[ij.y] * alpha
                    ) * INV_SPLIT_FACTOR;
                    
                    res.vn[e][1] = getNormal(a) * (1 - alpha) + getNormal(b) * alpha;
                }

                outTriangles[index + t] = res;
            }
        }
    }
}