// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel mapCubeCases FIRST_PASS
#pragma kernel marchCubes

#include "UnityShaderVariables.cginc"  // for time
#include "Noise.cginc"                 // Hiding creepy copy-paste

const uniform uint3 SPLIT_FACTOR;
const static float3 INV_SPLIT_FACTOR = 1.0 / SPLIT_FACTOR;
    
const static float3 DELTA = INV_SPLIT_FACTOR;
const static float3 DELTA_X = float3(1, 0, 0) * DELTA;
const static float3 DELTA_Y = float3(0, 1, 0) * DELTA;
const static float3 DELTA_Z = float3(0, 0, 1) * DELTA;

float f(float3 p) {   // implicit surface definition
    if (all(abs(p - 0.5) < 0.5)) {
        return snoise(p + _SinTime.xyz);
    }
    return 0.0;
}

float3 getPositionOfZeroF(float3 a, float3 b) {
    float t = abs(f(a)) / (abs(f(a)) + abs(f(b)));

    return a + t * (b - a);
}

float3 getNormal(float3 a) {
    return normalize(float3(
        f(a + DELTA_X) - f(a - DELTA_X),
        f(a + DELTA_Y) - f(a - DELTA_Y),
        f(a + DELTA_Z) - f(a - DELTA_Z)
    ));
}

// Cube
StructuredBuffer<float3> cubeVertices;

#ifdef FIRST_PASS

// Intermediate data
RWStructuredBuffer<int> caseIdsCount;
RWStructuredBuffer<int4> outCaseIds;
const uniform int inCubeCase;
RWStructuredBuffer<int4> inCaseIds;

[numthreads(4, 4, 4)]
void mapCubeCases (uint3 id : SV_DispatchThreadID)
{
    int cubeCase = 0;
    for (uint v = 0; v < 8; v++) {
        float3 vertex = (id + cubeVertices[v]) * INV_SPLIT_FACTOR;
        if (f(vertex) > 0) {
            cubeCase += 1 << v;
        }
    }

    if (cubeCase == inCubeCase) {
        int index;
        InterlockedAdd(caseIdsCount[0], 1, index);
        
        outCaseIds[index] = int4(id, inCubeCase);
    }
}

#else

// Marching
StructuredBuffer<uint> caseToTrianglesCount;
StructuredBuffer<int3> caseToEdges;

// Intermediate data
RWStructuredBuffer<int> caseIdsCount;
RWStructuredBuffer<int4> inCaseIds;

// Output triangles
RWStructuredBuffer<int> outTrianglesCount;
RWStructuredBuffer<float3> outVertices;
RWStructuredBuffer<int> outIndices;
RWStructuredBuffer<float3> outNormals;

[numthreads(256, 1, 1)]
void marchCubes (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= caseIdsCount[0]) {
        return;
    }
    int3 actualId = inCaseIds[id.x].xyz;
    int inCubeCase = inCaseIds[id.x].w;

    uint caseTriangles = caseToTrianglesCount[inCubeCase];
    int index;
    InterlockedAdd(outTrianglesCount[0], caseTriangles, index);
    
    for (uint t = 0; t < caseTriangles; t++) {
        int3 triangleEdges = caseToEdges[inCubeCase * 5 + t];

        for (uint e = 0; e < 3; e++) {
            uint i, j;
            uint edge = triangleEdges[e];
            if (edge < 4) {                                 
                i = edge;                                   
                j = (i + 1) % 4u;                           
            } else if (edge < 8) {                          
                i = edge;                                   
                j = 4 + (edge - 3) % 4u;                    
            } else {                                        
                i = edge % 4u;                              
                j = i + 4;                                  
            }                                               
                                                            
            float3 vertex = getPositionOfZeroF(            
                (actualId + cubeVertices[i]) * INV_SPLIT_FACTOR,  
                (actualId + cubeVertices[j]) * INV_SPLIT_FACTOR   
            );
            uint vertexIndex = 3 * (index + t) + e;
            
            outVertices[vertexIndex] = vertex;
            outIndices[vertexIndex] = vertexIndex;
            outNormals[vertexIndex] = getNormal(vertex);
        }
    }
}

#endif